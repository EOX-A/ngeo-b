#!/bin/bash
##############################################################################
# @maintained by: EOX IT Services GmbH
# @project Browse Server
# @version 1.1
# @date 2021-05-10
# @purpose Service script to ingest harvested browse reports.
#          To be placed in /etc/init.d/
##############################################################################
### BEGIN INIT INFO
# Provides: browsewatchd service
# Required-Start: $local_fs $network redis postgresql ngeo
# Required-Stop: $local_fs $network redis postgresql ngeo
# Default-Start: 2 3 5
# Default-Stop: 0 1 4 6
# Short-Description: Service script to ingest harvested browse reports.
# Description: To start, stop, restart browse watching
### END INIT INFO


# Source function library.
. /etc/init.d/functions

SERVICE="browsewatchd"
DAEMON_ID="$SERVICE" # must be unique for each daemon instance
PIDFILE="/var/run/${SERVICE}.pid"
HARD_KILL_DELAY=15 # seconds
LOCKFILE="/var/lock/subsys/$SERVICE"
CONSOLE_LOG="/var/www/ngeo/ngeo_browse_server_instance/ngeo_browse_server_instance/logs/${SERVICE}.log"
USER="apache"
REDIS_HOST=${HOST:-localhost}
REDIS_PORT=${PORT:-6379}
NUM_WORKERS=${NUM_WORKERS:-16}
EXEC_PATH="/usr/bin"
LOG_LEVEL="INFO"
#LOGLEVEL="DEBUG"
# comment following line to reduce the daemon's logging - not recommended during testing and benchmarking
EXTRA_OPTIONS="$EXTRA_OPTIONS --extra-logging"

COMMAND="runuser -s /bin/bash $USER -c 'ulimit -S -c 0 &>/dev/null ; nohup python ${EXEC_PATH}/browsewatchd2.py --id ${DAEMON_ID} --host ${REDIS_HOST} --port ${REDIS_PORT} --nworkers ${NUM_WORKERS} --verbosity ${LOG_LEVEL} ${EXTRA_OPTIONS} 0<&- &>>$CONSOLE_LOG & echo \$!' > $PIDFILE"

_status() {
    status -p "$PIDFILE" "$SERVICE"
}

_stop() {
    _PID=$(cat "$PIDFILE")
    [ -n "$_PID" ] || return 0 # no PID available - assuming stopped service
    _DELAY=$1
    while [ "$_DELAY" -gt 0 ]
    do
        [ -n "$(ps -o pid= $_PID)" ] || return 0 # not running
        kill "$_PID"
    echo -n "."
    sleep 1
    let _DELAY--
    done
    [ -n "$(ps -o pid= $_PID)" ] || return 0 # not running
    kill -9 "$_PID"
    echo -n "x"
    [ -z "$(ps -o pid= $_PID)" ]
}

start() {
  # check status and write message if something is wrong
  MSG="$( _status )"
  case "$?" in
    0 ) # running
      echo $"$MSG "
      touch "$LOCKFILE"
      return 0
    ;;
    1 | 2 ) # stopped with issues
      echo $"WARNING: $MSG"
    ;;
    3 ) # stopped
    ;;
    * ) # unexpected status
      echo $"ERROR: $MSG"
      return 1
    ;;
  esac
  # regular start-up
  # Check that redis and postgres are running
  if ! service redis status ; then
    failure && echo "Required service redis not running, exiting"
    return 1
  fi
  if ! service postgresql status ; then
    failure && echo "Required service postgresql not running, exiting"
    return 1
  fi
  echo -n $"starting $SERVICE: "
  daemon --pidfile="$PIDFILE" "$COMMAND"
  RETVAL="$?"
  echo
  [ "$RETVAL" -eq 0 ] && touch "$LOCKFILE"
  return "$RETVAL"
}

stop() {
  # check status and write message if something is wrong
  MSG="$( _status )"
  case "$?" in
    0 ) # running
    ;;
    1 | 2 ) # stopped with issues
      echo $"WARNING: $MSG "
      [ -f "$LOCKFILE" ] && rm -f "$LOCKFILE"
      [ -f "$PIDFILE" ] && rm -f "$PIDFILE"
      return 0
    ;;
    3 ) # stopped
      echo $"$MSG "
      return 0
    ;;
    * ) # unexpected status
      echo $"ERROR: $MSG"
      return 1
    ;;
  esac
  # regular shut-down
  echo -n $"stopping $SERVICE: "
  _stop ${HARD_KILL_DELAY:-1}
  RETVAL="$?"
  echo
  [ "$RETVAL" -eq 0 ] && rm -f "$LOCKFILE" "$PIDFILE"
  return "$RETVAL"
}

case "$1" in
  start)
    start
  ;;
  stop)
    stop
  ;;
  status)
    _status
  ;;
  restart)
    stop
    start
  ;;
  *)
    echo "Usage: $SERVICE {start|stop|status|restart"
    exit 1
  ;;
esac
exit "$?"
